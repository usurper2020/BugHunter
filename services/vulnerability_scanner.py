# services/vulnerability_scanner.py
import asyncio
import logging
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime
import json
import aiohttp
from pathlib import Path

@dataclass
class ScanTarget:
    url: str
    ip: Optional[str] = None
    ports: List[int] = None
    protocols: List[str] = None
    scope: Dict[str, any] = None

@dataclass
class ScanResult:
    target: str
    vulnerability_type: str
    severity: str
    description: str
    proof: str
    timestamp: datetime
    tool: str
    remediation: Optional[str] = None

class VulnerabilityScanner:
    def __init__(self):
        self.logger = logging.getLogger('BugHunter.VulnerabilityScanner')
        self.scan_history: Dict[str, Dict] = {}
        self.active_scans: Dict[str, asyncio.Task] = {}
        self.results_dir = Path('reports/scans')
        self.results_dir.mkdir(parents=True, exist_ok=True)

    async def start_scan(self, target: ScanTarget, scan_type: str = 'full') -> str:
        """Start a new vulnerability scan"""
        try:
            scan_id = f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            # Create scan configuration
            scan_config = {
                'id': scan_id,
                'target': target.__dict__,
                'type': scan_type,
                'start_time': datetime.now().isoformat(),
                'status': 'running'
            }

            # Save scan configuration
            self.scan_history[scan_id] = scan_config
            
            # Start scan task
            scan_task = asyncio.create_task(
                self._run_scan(scan_id, target, scan_type)
            )
            self.active_scans[scan_id] = scan_task

            self.logger.info(f"Started scan {scan_id} for {target.url}")
            return scan_id

        except Exception as e:
            self.logger.error(f"Failed to start scan: {e}")
            raise

    async def _run_scan(self, scan_id: str, target: ScanTarget, scan_type: str):
        """Run the actual scan"""
        try:
            results: List[ScanResult] = []
            
            # Run different scanning tools based on scan type
            if scan_type in ['full', 'recon']:
                results.extend(await self._run_amass_scan(target))
            
            if scan_type in ['full', 'vuln']:
                results.extend(await self._run_nuclei_scan(target))
                
            if scan_type in ['full', 'port']:
                results.extend(await self._run_nmap_scan(target))

            # Save results
            await self._save_results(scan_id, results)
            
            # Update scan status
            self.scan_history[scan_id]['status'] = 'completed'
            self.scan_history[scan_id]['end_time'] = datetime.now().isoformat()

        except Exception as e:
            self.logger.error(f"Scan {scan_id} failed: {e}")
            self.scan_history[scan_id]['status'] = 'failed'
            self.scan_history[scan_id]['error'] = str(e)
        finally:
            if scan_id in self.active_scans:
                del self.active_scans[scan_id]

    async def _run_amass_scan(self, target: ScanTarget) -> List[ScanResult]:
        """Run Amass subdomain enumeration"""
        results = []
        try:
            process = await asyncio.create_subprocess_exec(
                'amass', 'enum', '-d', target.url,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                for line in stdout.decode().splitlines():
                    if line.strip():
                        results.append(ScanResult(
                            target=target.url,
                            vulnerability_type='subdomain',
                            severity='info',
                            description=f'Subdomain found: {line}',
                            proof=line,
                            timestamp=datetime.now(),
                            tool='amass'
                        ))
        except Exception as e:
            self.logger.error(f"Amass scan failed: {e}")
        
        return results

    async def _run_nuclei_scan(self, target: ScanTarget) -> List[ScanResult]:
        """Run Nuclei vulnerability scan"""
        results = []
        try:
            process = await asyncio.create_subprocess_exec(
                'nuclei', '-u', target.url, '-json',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                for line in stdout.decode().splitlines():
                    try:
                        finding = json.loads(line)
                        results.append(ScanResult(
                            target=target.url,
                            vulnerability_type=finding['template-id'],
                            severity=finding['info']['severity'],
                            description=finding['info']['description'],
                            proof=finding['matched-at'],
                            timestamp=datetime.now(),
                            tool='nuclei',
                            remediation=finding['info'].get('remediation')
                        ))
                    except json.JSONDecodeError:
                        continue
        except Exception as e:
            self.logger.error(f"Nuclei scan failed: {e}")
        
        return results

    async def _run_nmap_scan(self, target: ScanTarget) -> List[ScanResult]:
        """Run Nmap port scan"""
        results = []
        try:
            process = await asyncio.create_subprocess_exec(
                'nmap', '-sV', '-sC', target.url,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                output = stdout.decode()
                results.append(ScanResult(
                    target=target.url,
                    vulnerability_type='port_scan',
                    severity='info',
                    description='Nmap scan results',
                    proof=output,
                    timestamp=datetime.now(),
                    tool='nmap'
                ))
        except Exception as e:
            self.logger.error(f"Nmap scan failed: {e}")
        
        return results

    async def _save_results(self, scan_id: str, results: List[ScanResult]):
        """Save scan results to file"""
        try:
            results_file = self.results_dir / f"{scan_id}.json"
            results_data = {
                'scan_id': scan_id,
                'scan_info': self.scan_history[scan_id],
                'findings': [vars(result) for result in results]
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post('http://localhost:8000/api/results', 
                                      json=results_data) as response:
                    if response.status != 200:
                        raise Exception(f"Failed to save results to API: {response.status}")

            with open(results_file, 'w') as f:
                json.dump(results_data, f, indent=2, default=str)
                
            self.logger.info(f"Saved scan results to {results_file}")

        except Exception as e:
            self.logger.error(f"Failed to save scan results: {e}")
            raise

    async def get_scan_status(self, scan_id: str) -> Dict:
        """Get the status of a specific scan"""
        if scan_id not in self.scan_history:
            raise ValueError(f"Scan {scan_id} not found")
            
        return self.scan_history[scan_id]

    async def stop_scan(self, scan_id: str):
        """Stop a running scan"""
        if scan_id in self.active_scans:
            self.active_scans[scan_id].cancel()
            self.scan_history[scan_id]['status'] = 'cancelled'
            self.logger.info(f"Cancelled scan {scan_id}")

    async def get_scan_results(self, scan_id: str) -> Dict:
        """Get the results of a specific scan"""
        results_file = self.results_dir / f"{scan_id}.json"
        if not results_file.exists():
            raise ValueError(f"Results for scan {scan_id} not found")
            
        with open(results_file, 'r') as f:
            return json.load(f)

    def get_scan_history(self) -> Dict[str, Dict]:
        """Get the history of all scans"""
        return self.scan_history
