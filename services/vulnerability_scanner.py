"""
Vulnerability scanning service for the BugHunter application.
Handles security scanning operations and vulnerability detection.
"""

import logging
import json
import asyncio
from pathlib import Path
from typing import Dict, List, Optional, Any
from datetime import datetime
from dataclasses import dataclass, asdict

@dataclass
class ScanTarget:
    """Represents a target for vulnerability scanning"""
    url: str
    scope: List[str]
    exclude: List[str]
    scan_type: str
    options: Dict[str, Any]

@dataclass
class ScanResult:
    """Represents the result of a vulnerability scan"""
    target: str
    timestamp: str
    vulnerabilities: List[Dict[str, Any]]
    scan_type: str
    duration: float
    status: str
    error: Optional[str] = None

class VulnerabilityScanner:
    """Manages vulnerability scanning operations"""
    
    def __init__(self):
        self.logger = logging.getLogger('BugHunter.VulnerabilityScanner')
        self.results_dir = Path('data/scan_results')
        self.results_dir.mkdir(parents=True, exist_ok=True)
        self.active_scans: Dict[str, asyncio.Task] = {}
        self.scan_configs: Dict[str, Dict[str, Any]] = {}
    
    def initialize(self) -> bool:
        """Initialize vulnerability scanner"""
        try:
            # Load scan configurations
            config_file = Path('config/scan_configs.json')
            if config_file.exists():
                with open(config_file, 'r') as f:
                    self.scan_configs = json.load(f)
            
            self.logger.info("Vulnerability scanner initialized successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Vulnerability scanner initialization failed: {str(e)}")
            return False
    
    async def start_scan(self, target: ScanTarget) -> str:
        """Start a new vulnerability scan"""
        try:
            # Generate scan ID
            scan_id = f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{target.scan_type}"
            
            # Create scan task
            scan_task = asyncio.create_task(
                self._run_scan(scan_id, target)
            )
            
            # Store active scan
            self.active_scans[scan_id] = scan_task
            
            self.logger.info(f"Started scan: {scan_id}")
            return scan_id
            
        except Exception as e:
            self.logger.error(f"Failed to start scan: {str(e)}")
            raise
    
    async def _run_scan(self, scan_id: str, target: ScanTarget) -> None:
        """Run the actual scan operation"""
        start_time = datetime.now()
        try:
            # Get scan configuration
            scan_config = self.scan_configs.get(target.scan_type)
            if not scan_config:
                raise ValueError(f"Invalid scan type: {target.scan_type}")
            
            # Initialize result
            result = ScanResult(
                target=target.url,
                timestamp=start_time.isoformat(),
                vulnerabilities=[],
                scan_type=target.scan_type,
                duration=0.0,
                status='running'
            )
            
            # Update scan status
            self._save_result(scan_id, result)
            
            # Run appropriate scanner based on scan type
            if target.scan_type == 'nuclei':
                vulnerabilities = await self._run_nuclei_scan(target)
            elif target.scan_type == 'custom':
                vulnerabilities = await self._run_custom_scan(target)
            else:
                raise ValueError(f"Unsupported scan type: {target.scan_type}")
            
            # Update result
            result.vulnerabilities = vulnerabilities
            result.status = 'completed'
            result.duration = (datetime.now() - start_time).total_seconds()
            
            # Save final result
            self._save_result(scan_id, result)
            
        except Exception as e:
            self.logger.error(f"Scan failed - {scan_id}: {str(e)}")
            # Update result with error
            result = ScanResult(
                target=target.url,
                timestamp=start_time.isoformat(),
                vulnerabilities=[],
                scan_type=target.scan_type,
                duration=(datetime.now() - start_time).total_seconds(),
                status='failed',
                error=str(e)
            )
            self._save_result(scan_id, result)
            
        finally:
            # Cleanup
            if scan_id in self.active_scans:
                del self.active_scans[scan_id]
    
    async def _run_nuclei_scan(self, target: ScanTarget) -> List[Dict[str, Any]]:
        """Run Nuclei vulnerability scanner"""
        try:
            from services.tool_manager import ToolManager
            tool_manager = ToolManager()
            
            # Prepare Nuclei arguments
            args = [
                '-target', target.url,
                '-json',
                '-silent'
            ]
            
            # Add scope
            for scope in target.scope:
                args.extend(['-scope', scope])
            
            # Add exclusions
            for exclude in target.exclude:
                args.extend(['-exclude', exclude])
            
            # Add custom options
            for key, value in target.options.items():
                args.extend([f'-{key}', str(value)])
            
            # Execute Nuclei
            result = await asyncio.to_thread(
                tool_manager.execute_tool,
                'nuclei',
                args
            )
            
            if result['status'] == 'error':
                raise Exception(f"Nuclei scan failed: {result.get('error')}")
            
            # Parse JSON output
            vulnerabilities = []
            for line in result['stdout'].splitlines():
                if line.strip():
                    try:
                        vuln = json.loads(line)
                        vulnerabilities.append(vuln)
                    except json.JSONDecodeError:
                        self.logger.warning(f"Failed to parse Nuclei output: {line}")
            
            return vulnerabilities
            
        except Exception as e:
            self.logger.error(f"Nuclei scan failed: {str(e)}")
            raise
    
    async def _run_custom_scan(self, target: ScanTarget) -> List[Dict[str, Any]]:
        """Run custom vulnerability scanner"""
        # Implement custom scanning logic here
        raise NotImplementedError("Custom scanning not implemented")
    
    def _save_result(self, scan_id: str, result: ScanResult):
        """Save scan result to file"""
        try:
            result_file = self.results_dir / f"{scan_id}.json"
            with open(result_file, 'w') as f:
                json.dump(asdict(result), f, indent=4)
        except Exception as e:
            self.logger.error(f"Failed to save scan result - {scan_id}: {str(e)}")
    
    def get_scan_status(self, scan_id: str) -> Optional[Dict[str, Any]]:
        """Get status of a scan"""
        try:
            result_file = self.results_dir / f"{scan_id}.json"
            if not result_file.exists():
                return None
            
            with open(result_file, 'r') as f:
                result = json.load(f)
            
            # Add active status
            result['active'] = scan_id in self.active_scans
            
            return result
            
        except Exception as e:
            self.logger.error(f"Failed to get scan status - {scan_id}: {str(e)}")
            return None
    
    def stop_scan(self, scan_id: str) -> bool:
        """Stop a running scan"""
        try:
            if scan_id in self.active_scans:
                # Cancel the task
                self.active_scans[scan_id].cancel()
                
                # Update result status
                result_file = self.results_dir / f"{scan_id}.json"
                if result_file.exists():
                    with open(result_file, 'r') as f:
                        result = json.load(f)
                    
                    result['status'] = 'cancelled'
                    
                    with open(result_file, 'w') as f:
                        json.dump(result, f, indent=4)
                
                del self.active_scans[scan_id]
                return True
            return False
            
        except Exception as e:
            self.logger.error(f"Failed to stop scan - {scan_id}: {str(e)}")
            return False
    
    def cleanup(self):
        """Cleanup scanner resources"""
        try:
            # Stop all active scans
            for scan_id in list(self.active_scans.keys()):
                self.stop_scan(scan_id)
            
            self.logger.info("Vulnerability scanner resources cleaned up")
            
        except Exception as e:
            self.logger.error(f"Scanner cleanup failed: {str(e)}")
